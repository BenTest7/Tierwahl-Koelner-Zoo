<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kölner Zoo – Tierfinder (Template Matching + Inselmaske)</title>
<style>
  :root{--bg:#0b1220;--panel:rgba(10,16,28,.72);--text:#e8edf7;--muted:rgba(232,237,247,.75);--border:rgba(255,255,255,.14);--red:#ef4444;}
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);}
  .wrap{height:100%;display:grid;grid-template-rows:auto 1fr;gap:10px;padding:10px;box-sizing:border-box;}
  .bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:10px;}
  .bar button,.bar input{
    border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); color:var(--text);
    padding:8px 10px;border-radius:999px;cursor:pointer;font-weight:650;font-size:12.5px;
  }
  .bar button:hover{background:rgba(255,255,255,.10);}
  .bar label{display:flex;gap:6px;align-items:center;font-size:12.5px;color:var(--muted);}
  .bar .spacer{flex:1;}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);font-size:12px;color:var(--muted);}
  .stage{position:relative;border:1px solid var(--border);border-radius:16px;overflow:hidden;background:#0f172a;}
  canvas{position:absolute;inset:0;width:100%;height:100%;}
  .hint{padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);font-size:12px;color:var(--muted);line-height:1.35}
</style>
</head>
<body>
<div class="wrap">
  <div class="bar">
    <button id="btnSelect">1) Tier auswählen</button>
    <button id="btnMatch" disabled>2) Gleiche Tiere finden</button>
    <button id="btnAddGroup" disabled>3) Als Gruppe speichern</button>
    <button id="btnReset">Reset Auswahl</button>
    <button id="btnExport">Export JSON</button>
    <div class="spacer"></div>
    <label>Empfindlichkeit
      <input id="thr" type="range" min="0.55" max="0.90" step="0.01" value="0.74"/>
      <span id="thrVal" class="pill">0.74</span>
    </label>
    <label>Max Treffer
      <input id="maxHits" type="number" min="10" max="400" step="10" value="120" style="width:84px"/>
    </label>
    <span id="status" class="pill">Lade Bilder…</span>
  </div>

  <div class="stage" id="stage">
    <canvas id="c"></canvas>
  </div>

  <div class="hint">
    <b>Ziel:</b> Du markierst pro Tierart einmal ein Beispiel (Rechteck), dann findet das Tool alle gleichen Icons – <b>nur innerhalb der Zoo-Insel</b> (Maskierung über Blanko V4).<br>
    <b>Workflow:</b> 1) „Tier auswählen“ → Rechteck um ein Tier-Icon ziehen → 2) „Gleiche Tiere finden“ → 3) „Als Gruppe speichern“ (z.B. <code>Flamingo</code>). Wiederholen für Elefant, Pinguin, Seelöwe, Banteng …<br>
    Danach „Export JSON“ hier im Chat einfügen → ich baue daraus deine finale Presenter+Publikum-Seite ohne dieses Tool.
  </div>
</div>

<script>
const ANIMALS_SRC = "zoo_animals_hd2.jpg";
const BLANK_SRC   = "zoo_blank_clean4_HD.png";

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { willReadFrequently:true });
const stage = document.getElementById("stage");
const statusEl = document.getElementById("status");

const btnSelect = document.getElementById("btnSelect");
const btnMatch  = document.getElementById("btnMatch");
const btnAddGroup = document.getElementById("btnAddGroup");
const btnReset  = document.getElementById("btnReset");
const btnExport = document.getElementById("btnExport");

const thr = document.getElementById("thr");
const thrVal = document.getElementById("thrVal");
const maxHitsEl = document.getElementById("maxHits");
thr.addEventListener("input", ()=> thrVal.textContent = Number(thr.value).toFixed(2));

let imgA = new Image(), imgB = new Image();
imgA.crossOrigin = "anonymous";
imgB.crossOrigin = "anonymous";

let imgW=0,imgH=0;
let mode="idle"; // idle|select
let sel=null;    // selection in work coords
let hits=[];     // hits in work coords
let groups=[];   // {name, hits:[{x,y,r,score}] } in work coords

const WORK_W = 1500;
let workCanvas=document.createElement("canvas");
let workCtx=workCanvas.getContext("2d", { willReadFrequently:true });
let blankCanvas=document.createElement("canvas");
let blankCtx=blankCanvas.getContext("2d", { willReadFrequently:true });
let islandMask=null; // Uint8Array workW*workH (1 inside island)

function fitCanvas(){
  const r=stage.getBoundingClientRect();
  canvas.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
  canvas.height= Math.max(1, Math.floor(r.height * devicePixelRatio));
  draw();
}
window.addEventListener("resize", fitCanvas);

function draw(){
  if(!imgW) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const r = stage.getBoundingClientRect();
  const vw=r.width, vh=r.height;
  const arImg=imgW/imgH, arV=vw/vh;
  let dw, dh, dx, dy;
  if(arImg > arV){ dw=vw; dh=vw/arImg; dx=0; dy=(vh-dh)/2; }
  else { dh=vh; dw=vh*arImg; dy=0; dx=(vw-dw)/2; }

  const dpr=devicePixelRatio;
  ctx.drawImage(imgA, dx*dpr, dy*dpr, dw*dpr, dh*dpr);

  const toScreen=(x,y)=>{
    const fx=x/workCanvas.width, fy=y/workCanvas.height;
    return { sx:(dx+fx*dw)*dpr, sy:(dy+fy*dh)*dpr, dw, dh, dx, dy, dpr };
  };

  // existing groups (faint)
  ctx.save();
  ctx.strokeStyle="rgba(239,68,68,0.35)";
  ctx.lineWidth=2*dpr;
  for(const g of groups){
    for(const h of g.hits){
      const p=toScreen(h.x,h.y);
      const rr = Math.max(6,h.r)/workCanvas.width * dw * dpr;
      ctx.beginPath(); ctx.arc(p.sx,p.sy,rr,0,Math.PI*2); ctx.stroke();
    }
  }
  ctx.restore();

  // current hits (strong)
  if(hits.length){
    ctx.save();
    ctx.strokeStyle="rgba(239,68,68,0.95)";
    ctx.lineWidth=3*dpr;
    for(const h of hits){
      const p=toScreen(h.x,h.y);
      const rr = Math.max(6,h.r)/workCanvas.width * dw * dpr;
      ctx.beginPath(); ctx.arc(p.sx,p.sy,rr,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();
  }

  // selection rectangle
  if(sel){
    const p0=toScreen(sel.x0,sel.y0);
    const p1=toScreen(sel.x1,sel.y1);
    const x=Math.min(p0.sx,p1.sx), y=Math.min(p0.sy,p1.sy);
    const w=Math.abs(p1.sx-p0.sx), h=Math.abs(p1.sy-p0.sy);
    ctx.save();
    ctx.strokeStyle="rgba(255,255,255,0.95)";
    ctx.lineWidth=2*dpr;
    ctx.setLineDash([6*dpr,4*dpr]);
    ctx.strokeRect(x,y,w,h);
    ctx.restore();
  }
}

function screenToWork(evt){
  const r=stage.getBoundingClientRect();
  const vw=r.width, vh=r.height;
  const arImg=imgW/imgH, arV=vw/vh;
  let dw, dh, dx, dy;
  if(arImg > arV){ dw=vw; dh=vw/arImg; dx=0; dy=(vh-dh)/2; }
  else { dh=vh; dw=vh*arImg; dy=0; dx=(vw-dw)/2; }
  const mx=(evt.clientX - r.left) - dx;
  const my=(evt.clientY - r.top) - dy;
  const fx=mx/dw, fy=my/dh;
  return {
    x: Math.max(0, Math.min(workCanvas.width-1, fx*workCanvas.width)),
    y: Math.max(0, Math.min(workCanvas.height-1, fy*workCanvas.height)),
  };
}

let dragging=false, start=null;
canvas.addEventListener("pointerdown",(e)=>{
  if(mode!=="select") return;
  dragging=true; start=screenToWork(e);
  sel={x0:start.x,y0:start.y,x1:start.x,y1:start.y};
  hits=[]; btnAddGroup.disabled=true;
  draw();
});
canvas.addEventListener("pointermove",(e)=>{
  if(!dragging || mode!=="select") return;
  const p=screenToWork(e);
  sel.x1=p.x; sel.y1=p.y;
  draw();
});
canvas.addEventListener("pointerup",()=>{
  if(mode!=="select") return;
  dragging=false;
  const x0=Math.min(sel.x0,sel.x1), x1=Math.max(sel.x0,sel.x1);
  const y0=Math.min(sel.y0,sel.y1), y1=Math.max(sel.y0,sel.y1);
  sel={x0,y0,x1,y1};
  const w=Math.abs(x1-x0), h=Math.abs(y1-y0);
  if(w<12 || h<12){ statusEl.textContent="Auswahl zu klein."; sel=null; btnMatch.disabled=true; }
  else { statusEl.textContent=`Template: ${Math.round(w)}×${Math.round(h)} (Work)`; btnMatch.disabled=false; }
  draw();
});

btnSelect.onclick=()=>{
  mode="select";
  statusEl.textContent="Ziehe ein Rechteck um EIN Tier-Icon.";
};

btnReset.onclick=()=>{
  sel=null; hits=[]; mode="idle";
  btnMatch.disabled=true; btnAddGroup.disabled=true;
  statusEl.textContent="Auswahl zurückgesetzt.";
  draw();
};

function getGray(imData, w, h){
  const out=new Float32Array(w*h);
  const d=imData.data;
  for(let i=0,j=0;i<d.length;i+=4,j++){
    out[j]=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])/255.0;
  }
  return out;
}

function nccMatch(imgG, imgW, imgH, tplG, tw, th, step, thr, maxHits){
  let tmean=0; for(let i=0;i<tplG.length;i++) tmean+=tplG[i]; tmean/=tplG.length;
  let tvar=0; for(let i=0;i<tplG.length;i++){ const v=tplG[i]-tmean; tvar+=v*v; } tvar=Math.sqrt(tvar)+1e-6;

  const raw=[];
  for(let y=0;y<=imgH-th;y+=step){
    for(let x=0;x<=imgW-tw;x+=step){
      // enforce island mask: require center inside island
      const cx = (x + tw/2) | 0;
      const cy = (y + th/2) | 0;
      if(!islandMask || islandMask[cy*imgW + cx]===0) continue;

      let mean=0, idx=0;
      for(let yy=0;yy<th;yy++){
        let row=(y+yy)*imgW + x;
        for(let xx=0;xx<tw;xx++,idx++) mean += imgG[row+xx];
      }
      mean /= (tw*th);

      let num=0, wvar=0; idx=0;
      for(let yy=0;yy<th;yy++){
        let row=(y+yy)*imgW + x;
        for(let xx=0;xx<tw;xx++,idx++){
          const a=imgG[row+xx]-mean;
          const b=tplG[idx]-tmean;
          num += a*b;
          wvar+= a*a;
        }
      }
      wvar=Math.sqrt(wvar)+1e-6;
      const score=num/(wvar*tvar);
      if(score>=thr) raw.push({x:cx,y:cy,r:Math.max(tw,th)/2,score});
    }
  }

  raw.sort((a,b)=>b.score-a.score);
  const out=[];
  const minDist=Math.max(tw,th)*0.55;
  for(const h of raw){
    if(out.length>=maxHits) break;
    if(out.every(o => (o.x-h.x)*(o.x-h.x)+(o.y-h.y)*(o.y-h.y) > minDist*minDist)){
      out.push(h);
    }
  }
  return out;
}

btnMatch.onclick=async()=>{
  if(!sel) return;
  statusEl.textContent="Suche…";
  await new Promise(r=>setTimeout(r,50));

  const imgData = workCtx.getImageData(0,0,workCanvas.width,workCanvas.height);
  const imgG = getGray(imgData, workCanvas.width, workCanvas.height);

  const x0=Math.round(Math.min(sel.x0,sel.x1)), x1=Math.round(Math.max(sel.x0,sel.x1));
  const y0=Math.round(Math.min(sel.y0,sel.y1)), y1=Math.round(Math.max(sel.y0,sel.y1));
  const tw=Math.max(12, x1-x0), th=Math.max(12, y1-y0);

  const tplData = workCtx.getImageData(x0,y0,tw,th);
  const tplG = getGray(tplData, tw, th);

  const threshold=Number(thr.value);
  const maxHits=Math.max(10,Math.min(400,Number(maxHitsEl.value)||120));
  const step = tw<=40 ? 2 : 3;

  hits = nccMatch(imgG, workCanvas.width, workCanvas.height, tplG, tw, th, step, threshold, maxHits);
  statusEl.textContent=`Treffer: ${hits.length}`;
  btnAddGroup.disabled = hits.length===0;
  draw();
};

btnAddGroup.onclick=()=>{
  if(!hits.length) return;
  const name = prompt("Gruppenname/Tierart (z.B. Flamingo, Elefant, Seelöwe):", "");
  if(!name) return;
  groups.push({name: name.trim(), hits: hits.map(h=>({...h}))});
  hits=[]; sel=null;
  btnMatch.disabled=true; btnAddGroup.disabled=true;
  statusEl.textContent=`Gruppe gespeichert: ${name}`;
  draw();
};

btnExport.onclick=async()=>{
  // export in normalized 0..100 coords for later HTML use
  const out = groups.map(g => ({
    name: g.name,
    points: g.hits.map(h => ({
      x: +(h.x / workCanvas.width * 100).toFixed(3),
      y: +(h.y / workCanvas.height * 100).toFixed(3),
      r: +(h.r / workCanvas.width * 100 * 1.15).toFixed(3), // scale radius into viewBox space
      score: +h.score.toFixed(3),
    }))
  }));
  const data = JSON.stringify(out, null, 2);
  try{ await navigator.clipboard.writeText(data); alert("JSON kopiert. Füge es hier im Chat ein."); }
  catch(e){ prompt("JSON kopieren:", data); }
};

function buildIslandMask(){
  // build island mask by comparing blank to its background: pixels inside island are non-background
  const imgData = blankCtx.getImageData(0,0,blankCanvas.width, blankCanvas.height);
  const d = imgData.data;
  // estimate background from corners (median)
  const sample=[];
  const step=4;
  const take=(sx,sy)=>{
    for(let y=sy;y<sy+60;y+=2){
      for(let x=sx;x<sx+60;x+=2){
        const i=(y*blankCanvas.width + x)*4;
        sample.push([d[i],d[i+1],d[i+2]]);
      }
    }
  };
  take(0,0); take(blankCanvas.width-60,0); take(0,blankCanvas.height-60); take(blankCanvas.width-60,blankCanvas.height-60);
  sample.sort((a,b)=> (a[0]+a[1]+a[2]) - (b[0]+b[1]+b[2]));
  const mid=sample[Math.floor(sample.length/2)] || [240,245,240];
  const br=mid[0], bg=mid[1], bb=mid[2];

  islandMask = new Uint8Array(blankCanvas.width*blankCanvas.height);
  for(let y=0;y<blankCanvas.height;y++){
    for(let x=0;x<blankCanvas.width;x++){
      const i=(y*blankCanvas.width + x)*4;
      const r=d[i], g=d[i+1], b=d[i+2];
      const dist = Math.abs(r-br)+Math.abs(g-bg)+Math.abs(b-bb);
      islandMask[y*blankCanvas.width + x] = dist > 22 ? 1 : 0;
    }
  }
  statusEl.textContent="Bereit. (1) Tier auswählen)";
}

function initWork(){
  imgW=imgA.naturalWidth; imgH=imgA.naturalHeight;
  const scale = Math.min(1, WORK_W / imgW);
  workCanvas.width = Math.round(imgW * scale);
  workCanvas.height= Math.round(imgH * scale);
  blankCanvas.width = workCanvas.width;
  blankCanvas.height= workCanvas.height;
  workCtx.drawImage(imgA, 0,0, workCanvas.width, workCanvas.height);
  blankCtx.drawImage(imgB, 0,0, blankCanvas.width, blankCanvas.height);
  buildIslandMask();
  fitCanvas();
}

let loaded=0;
function oneLoaded(){
  loaded++;
  if(loaded===2) initWork();
}
imgA.onload=oneLoaded;
imgB.onload=oneLoaded;
imgA.onerror=()=> statusEl.textContent="Konnte zoo_animals_hd2.jpg nicht laden.";
imgB.onerror=()=> statusEl.textContent="Konnte zoo_blank_clean4_HD.png nicht laden.";

imgA.src=ANIMALS_SRC;
imgB.src=BLANK_SRC;
</script>
</body>
</html>
